[toc]

# 数据库事务

## 定义

事务是逻辑上的一组数据库操作，要么都执行，要么都不执行。

例子：假如张三要给李四转账200元，这个转账会涉及到两个关键操作就是：将张三的余额减少200元，将李四的余额增加200元。如果两个操作之间突然出现错误，例如银行系统崩溃导致张三余额减少，而李四的余额没有增加，这样的系统是有问题的。事务就是保证这两个关键操作要么都成功，要么都要失败。

## 事务特性

事务具有 4 个特性，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），这 4 个特性通常简称为 ACID。

### 原子性

构成事务的的所有操作必须是一个逻辑单元，要么全部执行，要么全部不执行。

  比如，转账案例，用户A给用户B转账5000元主要步骤可以概括为如下两步。
　　第一，账户A账户减去5000元；
　　第二，账户B账户增加5000元； 这两部要么全执行，要么全不执行。若是第一步执行完，第二步还没执行，停电了。那么数据库重启后需要回滚到事务未执行之前的状态。

### 一致性

指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。 

这里的一致性状态是由业务层来决定的。比如转账案例，定义银行内部转账后金额总数不变就是正确的状态，即满足一致性。凡是转帐后金额总数变化了就不满足一致性。

我理解的是，AID这三个数据库本身的特性是为了确保一致性的基础。确保单个事务的一致性是编写该事务的应用程序员的责任。

### 隔离性

尽管多个事务并发执行，但每个事务都感受不到系统中其它事务在并发执行。

例如同时有T1和T2两个并发事务，从T1角度来看，T2要不在T1执行之前就已经结束，要么在T1执行完成后才开始。将多个事务隔离开，每个事务都不能访问到其他事务操作的中间状态。 

### 持久性

一个数据库成功完成后，它对数据库的改变必须是永久的，即使发生故障。 



事务的 ACID 原则保证了一个事务或者成功提交，或者失败回滚，二者必居其一。

## 事务之间的影响

### 脏读

即读到了其它事务回滚前的数据。

A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。就好像原本的数据比较干净、纯粹，此时由于B事务更改了它，这个数据变得不再纯粹。这个时候A事务立即读取了这个脏数据，但事务B良心发现，又用回滚把数据恢复成原来干净、纯粹的样子，而事务A却什么都不知道，最终结果就是事务A读取了此次的脏数据，称为脏读。

### 不可重复读

一个事务两次读同一行数据结果不同，且数据库未发生回滚。

事务A在执行读取操作，由整个事务A比较大，前后读取同一条数据需要经历很长的时间 。而在事务A第一次读取数据，比如此时读取了小明的年龄为20岁，事务B执行更改操作，将小明的年龄更改为30岁，此时事务A第二次读取到小明的年龄时，发现其年龄是30岁，和之前的数据不一样了，也就是数据不重复了，系统不可以读取到重复的数据，成为不可重复读。

### 幻读

事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样，就像产生了幻觉一样，平白无故的多了几条数据，成为幻读。

在同一个事务中，同一个查询多次返回的结果不一致。事务A新增了一条记录，事务B在事务A提交前后各执行了一次查询操作，发现后一次比前一次多了一条记录, 就好像发生了幻觉一样。

幻读是由于并发事务增加记录导致的，这个不能像不可重复读通过记录加锁解决，因为对于新增的记录根本无法加锁。需要将事务串行化，才能避免幻读。

不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于插入或删除。解决不可重复读的问题只需锁住满足条件的行，如果你要查全表数据，那么解决幻读需要锁表。

# 数据库隔离级别

### 数据库锁

数据库有4种隔离级别，为了保证隔离级别，常用到下面的锁。

**共享锁**(S锁):假设事务T1对数据A加上共享锁，那么事务T2**可以**读数据A，**不能**修改数据A。
**排他锁**(X锁):假设事务T1对数据A加上共享锁，那么事务T2**不能**读数据A，**不能**修改数据A。

## 读未提交（Read uncommitted)

最低的隔离级别，什么都不需要做，所有事务能够读取其他事务未提交的数据。在这种隔离级别下，所有的并发事务问题都会发生，如脏读、不可重复读、幻读。

### 实现

- 事务对当前读取的数据不加锁；
- 事务对数据更新前添加 **行级共享锁**，直到事务结束才释放。

### 可能发生的情况

- 事务1读取某些数据记录时，事务2也能对这些记录进行读取、更新；当事务2对这些记录进行更新时，事务1再次读取记录，能读到事务2对该记录的修改版本，即使更新尚未提交。
- 事务1更新某些数据记录时，事务2不能对这行记录做更新，直到事务1结束。

简单地理解就是：

- 允许事务同时读数据
- 允许一个事务读取数据同时另外一个事务修改数据
- 必须等更新数据的事务执行完成后，才能对执行其他的读取或者修改该数据的事务

## 读已提交（Read committed)

只有在事务提交后，其更新结果才会被其他事务看见，可以解决脏读问题。

在这种隔离级别下，所有事务只能读取其他事务已经提交的内容。但在这种隔离级别下，会出现一个事务的前后多次的查询中却返回了不同内容的数据的现象，也就是出现了不可重复读。

### 实现

- 事务对当前被读取的数据加 **行级共享锁（当读到时才加锁）**，一旦读完该行，立即释放该行级共享锁；
- 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 **行级排他锁**，直到事务结束才释放。

### 可能发生的情况

- 事务1读取某行记录时，事务2也能对这行记录进行读取、更新；当事务2对该记录进行更新时、
- 事务1再次读取该记录，读到的只能是事务2对其更新前的版本，要不就是事务2提交后的版本。
- 事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。

简单地理解就是：

- 允许事务同时读数据
- 必须一个事务读取完数据后，另外一个事务才能修改该数据
- 必须等更新数据的事务执行完成后，才能对执行其他的读取或者修改该数据的事务
  

## 可重复读（Repeatable read)

这是Mysql默认事务隔离级别。在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。

也就是某个事务在执行的过程中，不允许其他事务进行update操作，但允许其他事务进行add操作，造成某个事务前后多次读取到的数据总量不一致的现象，从而产生幻读。

###  实现

- 事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 **行级共享锁**，直到事务结束才释放；
- 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 **行级排他锁**，直到事务结束才释放。

这里与读已提交的区别是：可重复读事务读取数据先加行共享锁，事务结束才释放锁；而读已提交只要读完改行数据就会释放锁，不会等到整个事务结束。

### 可能发生的情况

- 事务1读取某行记录时，事务2也能对这行记录进行读取、更新；当事务2对该记录进行更新时
- 事务1再次读取该记录，读到的仍然是第一次读取的那个版本。
- 事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。
  简单地理解就是：

- 允许事务同时读数据

- 必须等读取数据的事务执行完成后，才能对执行其他的修改该数据的事务
- 必须等更新数据的事务执行完成后，才能对执行其他的读取或者修改该数据的事务
  

## 可串行化（Serializable)

在这种隔离级别下，所有的事务顺序执行，所以他们之间不存在冲突，从而能有效地解决脏读、不可重复读和幻读的现象。但是安全和效率不能兼得，这样事务隔离级别，会导致大量的操作超时和锁竞争，从而大大降低数据库的性能，一般不使用这样事务隔离级别。

### 实现

事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放；
事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。

### 可能发生的情况

- 事务1读取某行记录时，事务2也能对这行记录进行读取、更新；当事务2对该记录进行更新时
- 事务1再次读取该记录，读到的仍然是第一次读取的那个版本。
- 事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。

简单地理解就是：

所有的事务必须等上一个事务执行完成后才开始执行

| **隔离级别**                 | **脏读**  | **不可重复读** | **幻读** |
| ---------------------------- | --------- | -------------- | -------- |
| 读未提交（Read uncommitted） | ×(未解决) | ×              | ×        |
| 读已提交（Read committed）   | √(解决)   | ×              | ×        |
| 可重复读（Repeatable read）  | √         | √              | ×        |
| 可串行化（Serializable）     | √         | √              | √        |