# 锁粒度

## 行锁

行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。**行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。有可能会出现死锁的情况。** 

行级锁按照使用方式分为共享锁和排他锁。

共享锁（S锁 读锁）

允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。

若事务T对数据对象A加上S锁，则事务T**可以读A但不能修改A**，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

排他锁（X 锁 写锁）

允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。

若事务T对数据对象A加上X锁，事务T**可以读A也可以修改A**，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。

### 使用

共享锁

```mysql
select ... lock in share mode;
```

排他锁

```mysql
select ... for update
```

## 表锁

表级锁是mysql锁中粒度较大的一种锁，表示当前的操作对整张表加锁，**资源开销比行锁少，不会出现死锁的情况，但是发生锁冲突的概率很大**。被大部分的mysql引擎支持，MyISAM和InnoDB都支持表级锁，但是InnoDB默认的是行级锁。

### 使用

共享锁

```mysql
LOCK TABLE table_name [ AS alias_name ] READ
```

排他锁

```mysql
LOCK TABLE table_name [AS alias_name][ LOW_PRIORITY ] WRITE
```

释放锁

```mysql
unlock tables;
```

## 页锁

页级锁是MySQL中锁定粒度**介于行级锁和表级锁中间的一种锁**。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，**一次锁定相邻的一组记录**。

BDB存储引擎支持页级锁，我们用常用innodb存储引擎，用不到页锁，知道其概念即可。

## 全局锁

除了行锁，表锁，页锁外，这里还补充一种全局锁，这种锁的范围最大。
全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命 令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括 建表、修改表结构等）和更新类事务的提交语句。

全局锁的典型使用场景是，做全库逻辑备份。 全 也就是把整库每个表都select出来存成文本。

# 乐观锁与悲观锁

 乐观锁和悲观锁是并发控制主要采用的技术手段。无论是悲观锁还是乐观锁，人们提出来解决并发问题的一种思想。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像memcache、hibernate、tair、java等都有类似的概念。

## 悲观锁

### 概念

在关系数据库管理系统里，悲观锁（Pessimistic Concurrency Control）是一种并发控制的方法，它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作对某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。

悲观锁指的是对数据被外界（包括本系统当前的其他事务）修改持悲观态度，认为其他事务同时也想修改数据，因此，在整个数据处理过程中，将数据处于锁定状态。

 悲观锁的实现往往依靠数据库提供的锁机制 ，也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据。

### 悲观锁流程

在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）

如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。

如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。

其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。

## 乐观锁

乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突。在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。