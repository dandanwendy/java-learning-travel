# 锁粒度

## 行锁

行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。**行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。有可能会出现死锁的情况。** 

行级锁按照使用方式分为共享锁和排他锁。

共享锁（S锁 读锁）

允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。

若事务T对数据对象A加上S锁，则事务T**可以读A但不能修改A**，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

排他锁（X 锁 写锁）

允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。

若事务T对数据对象A加上X锁，事务T**可以读A也可以修改A**，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。

**X锁与任何锁都不兼容，而S锁仅和S锁兼容**。

### 使用

共享锁

```mysql
select ... lock in share mode;
```

排他锁

```mysql
select ... for update
```

## 表锁

表级锁是mysql锁中粒度较大的一种锁，表示当前的操作对整张表加锁，**资源开销比行锁少，不会出现死锁的情况，但是发生锁冲突的概率很大**。被大部分的mysql引擎支持，MyISAM和InnoDB都支持表级锁，但是InnoDB默认的是行级锁。

### 使用

共享锁

```mysql
LOCK TABLE table_name [ AS alias_name ] READ
```

排他锁

```mysql
LOCK TABLE table_name [AS alias_name][ LOW_PRIORITY ] WRITE
```

释放锁

```mysql
unlock tables;
```

## 页锁

页级锁是MySQL中锁定粒度**介于行级锁和表级锁中间的一种锁**。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，**一次锁定相邻的一组记录**。

BDB存储引擎支持页级锁，我们用常用innodb存储引擎，用不到页锁，知道其概念即可。

## 全局锁

除了行锁，表锁，页锁外，这里还补充一种全局锁，这种锁的范围最大。
全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命 令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括 建表、修改表结构等）和更新类事务的提交语句。

全局锁的典型使用场景是，做全库逻辑备份。 全 也就是把整库每个表都select出来存成文本。

# 乐观锁与悲观锁

 乐观锁和悲观锁是并发控制主要采用的技术手段。无论是悲观锁还是乐观锁，人们提出来解决并发问题的一种思想。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像memcache、hibernate、tair、java等都有类似的概念。

## 悲观锁

### 概念

在关系数据库管理系统里，悲观锁（Pessimistic Concurrency Control）是一种并发控制的方法，它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作对某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。

悲观锁指的是对数据被外界（包括本系统当前的其他事务）修改持悲观态度，认为其他事务同时也想修改数据，因此，在整个数据处理过程中，将数据处于锁定状态。

 悲观锁的实现往往依靠数据库提供的锁机制 ，也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据。

### 悲观锁流程

1）在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）

2）如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。

3）如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁。期间如果有其他连接对该记录做修改或加排他锁的操作，会等待锁释放或直接抛出异常。

### InnoDB中模拟悲观锁

首先关闭mysql中的autocommit属性，因为mysql默认使用自动提交模式，即执行一条sql之后会自动commit。关闭autocommit之后，我们才方便模拟悲观锁。

```mysql
mysql> set autocommit=0;
```

连接1

```mysql
BEGIN;
SELECT * FROM ms_tag FOR UPDATE;

COMMIT;  // 暂时不提交事务，只执行到上面加排它锁的行。连接2中的sql等待后再commit
```

连接2

```mysql
UPDATE ms_tag SET tag_name='springBoot7' WHERE id=5;
```

执行上面操作的时候，会显示等待状态。要么等到窗口1执行commit提交事务，释放锁；要么该sql长时间未获取到锁超时。

注意因为我们上面设置autocommit=0，这里的update语句也要commit，事务才能执行完。

### 悲观锁的优点和不足

悲观锁实际上是采取了“先取锁在访问”的策略，为数据的处理安全提供了保证。

但是在效率方面，由于额外的加锁机制产生了额外的开销，并且增加了死锁的机会。并且降低了并发性；当一个事物所以一行数据的时候，其他事物必须等待该事务提交之后，才能操作这行数据。

## 乐观锁

### 概念

乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突。在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。

相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。

数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。

### 乐观锁的优点和不足

 乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。

# 锁的算法

InnoDB有三种行锁的算法

## Record Lock

简单说就是单个行记录上加锁，防止事务间修改或删除数据。Record Lock总是会去锁住索引记录，如果表建立的时候没有设置任何一个索引，InnoDB存储引擎会使用隐式的主键来进行锁定。

## Gap Lock

间隙锁，是在索引的间隙之间加上锁，表示只锁住一段范围，**不锁记录本身**。通常表示两个索引记录之间，或者索引上的第一条记录之前，或者最后一条记录之后的锁。

因为在两条索引之间加锁，所以两条索引之间无法插入数据，这也是为什么Repeatable Read隔离级别下能防止幻读的主要原因。

### 解决幻读

首先幻读侧重于插入数据。由此可以想到解决幻读的方式，就是需要当事务进行当前读的时候，保证其他事务不可以在满足当前读条件的范围内进行数据操作。

如果你只是读某一小区间的数据，例如(1,3]U[3,4)两个区间里面，只要我们将这两个区间锁住，那么就不会发生幻读。当然如果你在读全表数据，此时要防止幻读，就得在表中所有区间都在 gap lock，这其实和锁表没区别了。

## Next-Key Lock

Gap Lock + Record Lock，锁定一个范围及锁定记录本身。

例如一个索引有10, 11, 13, 20这四个值，那么该索引可能被Next-key Locking的区间为`(负无穷, 10], (10, 11], (11, 13], (12, 20], (20, 正无穷)`。需要理解一点，InnoDB中加锁都是给所有记录一条一条加锁，并没有一个直接的范围可以直接锁住，所以会生成多个区间。

### 解决不可重复读

MySQL默认情况下使用RR的隔离级别，而Next-key Lock正是为了解决RR隔离级别下的不可重复读问题。所谓不可重复读就是一个事务内执行相同的查询，会看到不同的行记录，在RR隔离级别下这是不允许的。

假设索引上有记录`1，4，5，8，12`，我们执行类似语句`SELECT … WHERE col > 10 FOR UPDATE`。如果我们不在`(8, 12)`之间加上Next-key Lock，另外一个会话就可能向其中插入一条记录9，再执行一次相同的`SELECT ... FOR UPDATE`，就会看到新插入的记录。这也是为什么MySQL插入一条记录时，需要判断下一条记录上是否加锁了，如果加锁就需要等待。所以 Next-key 算法可以解决不可重复读问题。

InnoDB对行的查询默认采用Next-key算法。然而，当查询条件为等值时，且索引有唯一属性时（就是只锁定一条记录），InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身，而不是一个范围，因为此时不会产生重复读问题。

# 参考文档

[深度好文：MySQL锁](https://baijiahao.baidu.com/s?id=1709427910908845097&wfr=spider&for=pc)

[MySQL的锁机制和加锁原理](https://blog.csdn.net/qq_38238296/article/details/88362999?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-88362999-blog-121825980.pc_relevant_multi_platform_whitelistv1&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-88362999-blog-121825980.pc_relevant_multi_platform_whitelistv1&utm_relevant_index=1)